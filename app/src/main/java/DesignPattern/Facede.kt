package DesignPattern

/**
 * 外观模式：
 *      为子系统中的一组接口提供了一个一致的界面，Facade模式定义了一个高层接口，这个接口使得
 *      这一子系统更加容易使用。
 *
 *      Facede:定义子系统的多个模块的高层接口，通常需要调用内部多个模块，从而把客户端的请求代理给
 *      适当的子系统对象。
 *      模块：接受Facade对象的委派，真正的实现，各个模块之间可能有交互。
 *          注意，Facade对象知道各个模块，但是各个模块不知道Facade对象。
 *
 *     外观模式的目的：
 *          外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互。
 *          松散耦合，从而让外部更加简单的使用子系统。
 *
 *     今天不写代码随便提交点吧。
 *
 *     使用外观模式和不使用有啥区别：
 *          Facade方便了客户端的调用，封装了系统内部的细节功能，实现功能的共享和复用。
 *     3 有外观但是可以不使用。
 *     4 外观提供了缺省的功能实现。
 *
 *
 *     外观模式的实现：
 *          1 把外观模式当成一个辅助工具类实现。
 *          2 把Facade实现成interface。
 *
 *
 *     外观模式的本质：
 *          封装交互，简化调用。
 *     何时选用外观模式
 *          1 如果你希望为一个复杂的子系统提供一个简单接口时，可以考虑使用外观模式。使用外观模式。
 *          使用外观模式来实现大部分客户需要的功能，从而简化客户的使用。
 *          2 如果想要让客户程序和抽象类的实现部分松散耦合，可以使用外观模式。使用外观对象来将这个子系统
 *          与它的客户分离开来。从而提高子系统的独立性和可移植性。
 *
 *
 *
 *
 *
 */