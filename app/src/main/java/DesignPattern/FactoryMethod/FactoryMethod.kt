package DesignPattern.FactoryMethod


/**
 * 工厂方法：
 *      定义一个用于创建对象的接口，让子类决定实例化哪一个类，FactoryMethod使一个的
 *      实例化延迟到其子类。
 *      1 主要功能：工厂方法的主要功能是让父类在不知道具体实现的情况下，完成自身功能的
 *      功能调用，而具体的实现延迟到子类来实现。
 *
 *
 *      2 实现成抽象类
 *          工厂方法的实现中，通常父类是一个抽象类，里面包含创建对象的抽象方法，这些抽象方法
 *          就是工厂方法。又要约束子类的行为，又要为子类提供公共的功能。
 *      3 实现成具体的类
 *          则提供了一个默认的实现。
 *
 *      5 谁来使用工厂方法创建的对象？
 *          1 在工厂方法模式里面，应该Creator中的--其他方法--在使用工厂方法创建的对象。
 *          2 客户端应该是使用Creator对象，或者是使用由Creator创建出来的对象，这个时候
 *          工厂方法创建的对象，是Creator中某些方法使用。
 *          3 在某些情况下，客户端可能会使用由Creator创建的对象，这个时候工厂方法创建的对象
 *          ，是构成客户端需要的对象的一部分。
 *
 * 例子：
 *      Product:定义工厂方法所创建对象的接口，也就是实际需要使用的对象的接口。
 *      ConcreteProduct：具体的Product接口的实现对象。
 *      Creator：创建器，声明工厂方法。
 *      ConcreteCreator：具体的创建器对象，覆盖实现Createor的定义的工厂方法，返回具体的Product
 *      实例。
 *
 *
 *      简单工厂存在的问题：
 *              *工厂类集中了所有产品的创建逻辑。一旦工厂不能正常工作，整个系统都会收到影响。
 *              *违背开闭原则，一旦添加新产品，必须修改整个工厂类的逻辑。
 *              *使用了静态工厂方法，继承结构上有问题。
 *
 *
 *
 *
 *      工厂方法模式与IOC/DI的关系
 *          1 概念
 *              依赖注入：应用程序依赖容器创建并注入它所需要的外部资源。
 *              控制反转：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。
 *          2 理解
 *              1 参与者都有谁？ 应用程序，容器。
 *              2 依赖：谁依赖谁？ 为什么需要依赖？ 应用程序-->依赖-->容器
 *              3 注入：谁注入谁？ 到底注入什么？ 注入外部资源。
 *              4 控制反转： 谁控制谁？ 控制什么？为何叫反转？
 *              5 依赖注入和控制反转是同一概念吗？
 *         ***依赖：1 依赖关系 2 谁依赖于谁
 *         IOC/DI对编程带来的最大改变不是从代码上，而是从思想上。发生了主从换位的思想。应用程序
 *         原本是老大，要获取什么资源就主动出击。但是在IOC/DI中，应用程序变得被动，被动的等待IOC
 *         容器来创建并注入它所需要的资源。
 *         松散耦合，有利于功能复用。体系结构灵活。
 *
 */

/**
 * spi：
 * 为某个接口寻找服务实现的机制，将装配的控制权转移到了程序之外。类似与IOC思想。
 * SPI: Service provider interface（接口属于调用方）
 *      1 概念上更依赖于调用方法。
 *      2 组织上位于调用方法所在的包中。
 *      3 实现位于独立的包中，也可以认为在提供方中。
 *
 *
 *
 * API：（接口属于实现方）
 *      1 概念上更接近于实现方。
 *      2 组织上位于实现方所在的包中。
 *      3 实现和接口在一个包中。
 *
 *
 * JDK6 ServiceLoad
 *
 *      1 平行的类层次结构
 *          什么是平行的类层次结构：假如有两个类层次结构，其中一个类层次中在另一个类层次中，
 *          都有一个对应的类的结构，就被称为平行的类层次结构。
 *      2 类层次结构用来做什么？
 *          主要用于把一个类层次中的某些行为分离出来。让类层次中的类把原本属于自己的职责，委托
 *          给分离出去的类去实现，从而使得类层次本身变得更加简单，更容易拓展和复用。
 *      3 工厂方法模式和平行的类层次结构有何关系
 */

/**
 * 参数化工厂
 * 工厂模式的优缺点：
 *      1 可以在不知具体实现的情况下编程。
 *      2 更容易拓展对象的新版本。
 *      3 连接平行的类层次结构。
 *      4 分离具体的产品对象和工厂方法的耦合性。
 *
 * 工厂方法的本质：
 *      延迟到子类来选择实现。
 *
 * 对设计原则的体系：
 *      很好的体现了-----依赖倒置原则。（倒置：接口的归属权）
 *      要依赖抽象，不要依赖于具体类。简单点说：不能让高层组件依赖于低层组件，而且不管高层组件
 *      还是低层组件，都应该依赖于抽象。
 *
 * 何时选用工厂方法模式？
 *      1 只知接口不知实现。
 *      2 如果一个类本身就希望由它的子类来创建所需的对象的时候。应该使用工厂方法模式。
 *
 *
 *
 */